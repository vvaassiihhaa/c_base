#include <stdio.h>
#define MAX_LENGTH    20

size_t to_flat( short* v, /* массив, в который заносятся значения */
        size_t max_len_v, /* максимальная длина массива v */
        short* table[],   /* массив на массив, из которого читаются значения */
        size_t len,       /* длина массива table (первая размерность) */
        size_t count_v,   /* число записанных в массив v значений (начальное значение 0) */
        size_t indx_t,    /* индекс для перебора указателей (первой размерности) массива table (начальное значение 0) */
        size_t indx)      /* индекс для перебора элементов массивов (условно, вторая размерность), 
                        на которые ссылается текущий указатель table[indx_t] (начальное значение 0)*/
{

    // Проверяем, достигли ли мы максимальной длины массива v
    if (count_v >= max_len_v) {
        return count_v;
    }

    // Проверяем, достигли ли конца массива table
    if (indx_t >= len) {
        return count_v;
    }

    // Если текущий элемент массива table не равен нулю, добавляем его в массив v
    if (table[indx_t][indx] != 0) {
        v[count_v] = table[indx_t][indx];
        // Рекурсивно вызываем функцию для следующего элемента
        return to_flat(v, max_len_v, table, len, count_v + 1, indx_t, indx + 1);
    } else {
        // Если текущий элемент массива table равен нулю, переходим к следующему указателю в table
        // и начинаем с нулевого индекса
        return to_flat(v, max_len_v, table, len, count_v, indx_t + 1, 0);
    }

}

// v         - массив, в который заносятся значения
// max_len_v - максимальная длина массива v
// len       - длина массива table ( первая размерность ) = 4
// count_v   - число записанных в массив v значений ( начальное значение 0 )
// indx_t    - индекс для перебора указателей (первой размерности) массива table ( начальное значение 0 )
// indx      - индекс для перебора элементов массивов (у словно, вторая размерность )
//             на которые ссылается текущий указатель table[ indx_t ] ( начальное значение 0 )
 
// to_flat( flat, MAX_LENGTH, table, sizeof( table ) / sizeof( *table ), 0, 0, 0 );

int main(void)
{
    short ar_1[] = { -4, 2, 3, 7, 0 };
    short ar_2[] = { 11, 6, 10, 8, 13, 98, -5, 0 };
    short ar_3[] = { -47, 0 };
    short ar_4[] = { 8, 11, 56, -3, -2, 0 };

    short * table[] = { ar_1, ar_4, ar_3, ar_2 }; // массив на массив, из которого читаются значения

    short flat[MAX_LENGTH]; // массив, в который заносятся значения

    size_t cnt = to_flat( flat, MAX_LENGTH, table, sizeof(table) / sizeof(*table), 0, 0, 0);

    for(int i = 0;i < cnt; ++i)
        printf("%d ", flat[i]);

    return 0;
}

/*

Подвиг 5*. Продолжите программу. 

Необходимо дописать рекурсивную функцию to_flat, 

которая в одномерный массив v по порядку заносит целые числа из таблицы чисел table. 

Таблица представляет собой массив указателей на целочисленные массивы:

В конце каждого одномерного массива всегда стоит число 
0 - маркер конца данных. 

Максимальное число записываемых в массив v данных составляет max_len_v ( превышать это значение нельзя ). 

На выходе функция to_flat возвращает количество записанных в массив v числовых значений.

Например, для следующих данных:

short ar_1[] = {1, 2, 3, 0};
short ar_2[] = {4, 5, 6, 7, 8, 0};
short ar_3[] = {-1, -2, 0};
short ar_4[] = {-3, -4, -5, 0};
short * table[] = {ar_1, ar_4, ar_3, ar_2};

Функция to_flat в массив v должна занести числовые значения:

1 2 3 -3 -4 -5 -1 -2 4 5 6 7 8

P. S. Рекурсивная функция to_flat ничего в консоль выводить не должна. 

Также в теле функции to_flat недопустимо использовать какие-либо операторы циклов.


https://stepik.org/lesson/1191308/step/7?unit=1204296

*/